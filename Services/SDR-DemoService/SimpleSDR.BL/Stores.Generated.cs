using MedicalResearch.SubjectData;
using MedicalResearch.SubjectData.Persistence;
using MedicalResearch.SubjectData.Persistence.EF;
using MedicalResearch.SubjectData.Model;
using System;
using System.Data;
using System.Data.AccessControl;
using System.Linq;
using System.ComponentModel.DataAnnotations;
using System.Collections.ObjectModel;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace MedicalResearch.SubjectData.StoreAccess {

/// <summary> Provides CRUD access to stored Subjects (based on schema version '0.1.0') </summary>
public partial class SubjectStore : ISubjects {

  private ILogger _Logger = null;
  public SubjectStore(ILogger<SubjectStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific Subject addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="subjectUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public Subject GetSubjectBySubjectUid(Guid subjectUid){
    var mac = AccessControlContext.Current;

    Subject result;
    using (SubjectDataDbContext db = new SubjectDataDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.Subjects.AsNoTracking().AccessScopeFiltered().Select(SubjectEntity.SubjectSelector);

      query = query.Where((e)=>e.SubjectUid == subjectUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads Subjects. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of Subjects which should be returned </param>
  public Subject[] GetSubjects(int page = 1, int pageSize = 20){
    return this.SearchSubjects(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {"TerminatedReason", "SubjectIdentifier", "Status"};

  /// <summary> Loads Subjects where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of Subjects which should be returned</param>
  public Subject[] SearchSubjects(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    Subject[] result;
    using (SubjectDataDbContext db = new SubjectDataDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.Subjects
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(SubjectEntity.SubjectSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("SubjectUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", SubjectUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new Subject and returns success. </summary>
  /// <param name="subject"> Subject containing the new values </param>
  public bool AddNewSubject(Subject subject){
    var mac = AccessControlContext.Current;

    SubjectEntity newEntity = new SubjectEntity();
    newEntity.CopyContentFrom(subject);

    using (SubjectDataDbContext db = new SubjectDataDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding Subject failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.Subjects.Where((e)=>e.SubjectUid == newEntity.SubjectUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding Subject failed: already existing record with this PK!");
        }
        return false;
      }

      db.Subjects.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A Subject was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given Subject addressed by the primary identifier fields within the given Subject. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="subject"> Subject containing the new values (the primary identifier fields within the given Subject will be used to address the target record) </param>
  public bool UpdateSubject(Subject subject){
    return this.UpdateSubjectBySubjectUid(subject.SubjectUid, subject);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given Subject addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="subjectUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  /// <param name="subject"> Subject containing the new values (the primary identifier fields within the given Subject will be ignored) </param>
  public bool UpdateSubjectBySubjectUid(Guid subjectUid, Subject subject){
    var mac = AccessControlContext.Current;

    SubjectEntity existingEntity;
    using (SubjectDataDbContext db = new SubjectDataDbContext()) {

      IQueryable<SubjectEntity> query = db.Subjects;

      query = query.Where((e)=>e.SubjectUid == subjectUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating Subject failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(subject, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating Subject failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating Subject failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A Subject was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific Subject addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="subjectUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public bool DeleteSubjectBySubjectUid(Guid subjectUid){
    var mac = AccessControlContext.Current;

    SubjectEntity existingEntity;
    using (SubjectDataDbContext db = new SubjectDataDbContext()) {

      IQueryable<SubjectEntity> query = db.Subjects.AccessScopeFiltered();

      query = query.Where((e)=>e.SubjectUid == subjectUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating Subject failed: no record with this PK!");
        }
        return false;
      }

      db.Subjects.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A Subject was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(SubjectEntity entity, SubjectDataDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<SubjectEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    return true;
  }

}

/// <summary> Provides CRUD access to stored SubjectSiteAssignments (based on schema version '0.1.0') </summary>
public partial class SubjectSiteAssignmentStore : ISubjectSiteAssignments {

  private ILogger _Logger = null;
  public SubjectSiteAssignmentStore(ILogger<SubjectSiteAssignmentStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific SubjectSiteAssignment addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="subjectSiteAssignmentUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public SubjectSiteAssignment GetSubjectSiteAssignmentBySubjectSiteAssignmentUid(Guid subjectSiteAssignmentUid){
    var mac = AccessControlContext.Current;

    SubjectSiteAssignment result;
    using (SubjectDataDbContext db = new SubjectDataDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.SubjectSiteAssignments.AsNoTracking().AccessScopeFiltered().Select(SubjectSiteAssignmentEntity.SubjectSiteAssignmentSelector);

      query = query.Where((e)=>e.SubjectSiteAssignmentUid == subjectSiteAssignmentUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads SubjectSiteAssignments. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of SubjectSiteAssignments which should be returned </param>
  public SubjectSiteAssignment[] GetSubjectSiteAssignments(int page = 1, int pageSize = 20){
    return this.SearchSubjectSiteAssignments(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {"SiteRelatedPatientIdentifier"};

  /// <summary> Loads SubjectSiteAssignments where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of SubjectSiteAssignments which should be returned</param>
  public SubjectSiteAssignment[] SearchSubjectSiteAssignments(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    SubjectSiteAssignment[] result;
    using (SubjectDataDbContext db = new SubjectDataDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.SubjectSiteAssignments
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(SubjectSiteAssignmentEntity.SubjectSiteAssignmentSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("SubjectSiteAssignmentUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", SubjectSiteAssignmentUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new SubjectSiteAssignment and returns success. </summary>
  /// <param name="subjectSiteAssignment"> SubjectSiteAssignment containing the new values </param>
  public bool AddNewSubjectSiteAssignment(SubjectSiteAssignment subjectSiteAssignment){
    var mac = AccessControlContext.Current;

    SubjectSiteAssignmentEntity newEntity = new SubjectSiteAssignmentEntity();
    newEntity.CopyContentFrom(subjectSiteAssignment);

    using (SubjectDataDbContext db = new SubjectDataDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding SubjectSiteAssignment failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.SubjectSiteAssignments.Where((e)=>e.SubjectSiteAssignmentUid == newEntity.SubjectSiteAssignmentUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding SubjectSiteAssignment failed: already existing record with this PK!");
        }
        return false;
      }

      db.SubjectSiteAssignments.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SubjectSiteAssignment was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given SubjectSiteAssignment addressed by the primary identifier fields within the given SubjectSiteAssignment. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="subjectSiteAssignment"> SubjectSiteAssignment containing the new values (the primary identifier fields within the given SubjectSiteAssignment will be used to address the target record) </param>
  public bool UpdateSubjectSiteAssignment(SubjectSiteAssignment subjectSiteAssignment){
    return this.UpdateSubjectSiteAssignmentBySubjectSiteAssignmentUid(subjectSiteAssignment.SubjectSiteAssignmentUid, subjectSiteAssignment);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given SubjectSiteAssignment addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="subjectSiteAssignmentUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  /// <param name="subjectSiteAssignment"> SubjectSiteAssignment containing the new values (the primary identifier fields within the given SubjectSiteAssignment will be ignored) </param>
  public bool UpdateSubjectSiteAssignmentBySubjectSiteAssignmentUid(Guid subjectSiteAssignmentUid, SubjectSiteAssignment subjectSiteAssignment){
    var mac = AccessControlContext.Current;

    SubjectSiteAssignmentEntity existingEntity;
    using (SubjectDataDbContext db = new SubjectDataDbContext()) {

      IQueryable<SubjectSiteAssignmentEntity> query = db.SubjectSiteAssignments;

      query = query.Where((e)=>e.SubjectSiteAssignmentUid == subjectSiteAssignmentUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SubjectSiteAssignment failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(subjectSiteAssignment, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SubjectSiteAssignment failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating SubjectSiteAssignment failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SubjectSiteAssignment was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific SubjectSiteAssignment addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="subjectSiteAssignmentUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public bool DeleteSubjectSiteAssignmentBySubjectSiteAssignmentUid(Guid subjectSiteAssignmentUid){
    var mac = AccessControlContext.Current;

    SubjectSiteAssignmentEntity existingEntity;
    using (SubjectDataDbContext db = new SubjectDataDbContext()) {

      IQueryable<SubjectSiteAssignmentEntity> query = db.SubjectSiteAssignments.AccessScopeFiltered();

      query = query.Where((e)=>e.SubjectSiteAssignmentUid == subjectSiteAssignmentUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SubjectSiteAssignment failed: no record with this PK!");
        }
        return false;
      }

      db.SubjectSiteAssignments.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SubjectSiteAssignment was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(SubjectSiteAssignmentEntity entity, SubjectDataDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<SubjectSiteAssignmentEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    if(!db.Subjects.Where((tgt)=> tgt.SubjectUid==entity.SubjectUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    return true;
  }

}

}
