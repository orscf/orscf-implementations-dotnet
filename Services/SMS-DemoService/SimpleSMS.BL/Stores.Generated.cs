using MedicalResearch.StudyManagement;
using MedicalResearch.StudyManagement.Persistence;
using MedicalResearch.StudyManagement.Persistence.EF;
using MedicalResearch.StudyManagement.Model;
using System;
using System.Data;
using System.Data.AccessControl;
using System.Linq;
using System.ComponentModel.DataAnnotations;
using System.Collections.ObjectModel;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace MedicalResearch.StudyManagement.StoreAccess {

/// <summary> Provides CRUD access to stored Institutes (based on schema version '1.6.0') </summary>
public partial class InstituteStore : IInstitutes {

  private ILogger _Logger = null;
  public InstituteStore(ILogger<InstituteStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific Institute addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="instituteUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public Institute GetInstituteByInstituteUid(Guid instituteUid){
    var mac = AccessControlContext.Current;

    Institute result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.Institutes.AsNoTracking().AccessScopeFiltered().Select(InstituteEntity.InstituteSelector);

      query = query.Where((e)=>e.InstituteUid == instituteUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads Institutes. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of Institutes which should be returned </param>
  public Institute[] GetInstitutes(int page = 1, int pageSize = 20){
    return this.SearchInstitutes(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {"DisplayLabel"};

  /// <summary> Loads Institutes where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of Institutes which should be returned</param>
  public Institute[] SearchInstitutes(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    Institute[] result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.Institutes
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(InstituteEntity.InstituteSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("InstituteUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", InstituteUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new Institute and returns success. </summary>
  /// <param name="institute"> Institute containing the new values </param>
  public bool AddNewInstitute(Institute institute){
    var mac = AccessControlContext.Current;

    InstituteEntity newEntity = new InstituteEntity();
    newEntity.CopyContentFrom(institute);

    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding Institute failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.Institutes.Where((e)=>e.InstituteUid == newEntity.InstituteUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding Institute failed: already existing record with this PK!");
        }
        return false;
      }

      db.Institutes.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A Institute was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given Institute addressed by the primary identifier fields within the given Institute. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="institute"> Institute containing the new values (the primary identifier fields within the given Institute will be used to address the target record) </param>
  public bool UpdateInstitute(Institute institute){
    return this.UpdateInstituteByInstituteUid(institute.InstituteUid, institute);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given Institute addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="instituteUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  /// <param name="institute"> Institute containing the new values (the primary identifier fields within the given Institute will be ignored) </param>
  public bool UpdateInstituteByInstituteUid(Guid instituteUid, Institute institute){
    var mac = AccessControlContext.Current;

    InstituteEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<InstituteEntity> query = db.Institutes;

      query = query.Where((e)=>e.InstituteUid == instituteUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating Institute failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(institute, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating Institute failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating Institute failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A Institute was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific Institute addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="instituteUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public bool DeleteInstituteByInstituteUid(Guid instituteUid){
    var mac = AccessControlContext.Current;

    InstituteEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<InstituteEntity> query = db.Institutes.AccessScopeFiltered();

      query = query.Where((e)=>e.InstituteUid == instituteUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating Institute failed: no record with this PK!");
        }
        return false;
      }

      db.Institutes.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A Institute was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(InstituteEntity entity, StudyManagementDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<InstituteEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    if(!db.SystemEndpoints.Where((tgt)=> tgt.SystemEndpointUid==entity.OwnPatientSdrEndpointUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    return true;
  }

}

/// <summary> Provides CRUD access to stored ResearchStudies (based on schema version '1.6.0') </summary>
public partial class ResearchStudyStore : IResearchStudies {

  private ILogger _Logger = null;
  public ResearchStudyStore(ILogger<ResearchStudyStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific ResearchStudy addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="researchStudyUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public ResearchStudy GetResearchStudyByResearchStudyUid(Guid researchStudyUid){
    var mac = AccessControlContext.Current;

    ResearchStudy result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.ResearchStudies.AsNoTracking().AccessScopeFiltered().Select(ResearchStudyEntity.ResearchStudySelector);

      query = query.Where((e)=>e.ResearchStudyUid == researchStudyUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads ResearchStudies. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of ResearchStudies which should be returned </param>
  public ResearchStudy[] GetResearchStudies(int page = 1, int pageSize = 20){
    return this.SearchResearchStudies(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {"DisplayLabel", "StudyWorkflowName", "StudyWorkflowVersion", "Phase", "SubjectIdentifierTitle", "Status", "TerminatedReason", "InitiatorRelatedProjectNumber"};

  /// <summary> Loads ResearchStudies where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of ResearchStudies which should be returned</param>
  public ResearchStudy[] SearchResearchStudies(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    ResearchStudy[] result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.ResearchStudies
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(ResearchStudyEntity.ResearchStudySelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("ResearchStudyUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", ResearchStudyUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new ResearchStudy and returns success. </summary>
  /// <param name="researchStudy"> ResearchStudy containing the new values </param>
  public bool AddNewResearchStudy(ResearchStudy researchStudy){
    var mac = AccessControlContext.Current;

    ResearchStudyEntity newEntity = new ResearchStudyEntity();
    newEntity.CopyContentFrom(researchStudy);

    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding ResearchStudy failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.ResearchStudies.Where((e)=>e.ResearchStudyUid == newEntity.ResearchStudyUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding ResearchStudy failed: already existing record with this PK!");
        }
        return false;
      }

      db.ResearchStudies.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A ResearchStudy was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given ResearchStudy addressed by the primary identifier fields within the given ResearchStudy. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="researchStudy"> ResearchStudy containing the new values (the primary identifier fields within the given ResearchStudy will be used to address the target record) </param>
  public bool UpdateResearchStudy(ResearchStudy researchStudy){
    return this.UpdateResearchStudyByResearchStudyUid(researchStudy.ResearchStudyUid, researchStudy);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given ResearchStudy addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="researchStudyUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  /// <param name="researchStudy"> ResearchStudy containing the new values (the primary identifier fields within the given ResearchStudy will be ignored) </param>
  public bool UpdateResearchStudyByResearchStudyUid(Guid researchStudyUid, ResearchStudy researchStudy){
    var mac = AccessControlContext.Current;

    ResearchStudyEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<ResearchStudyEntity> query = db.ResearchStudies;

      query = query.Where((e)=>e.ResearchStudyUid == researchStudyUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating ResearchStudy failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(researchStudy, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating ResearchStudy failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating ResearchStudy failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A ResearchStudy was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific ResearchStudy addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="researchStudyUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public bool DeleteResearchStudyByResearchStudyUid(Guid researchStudyUid){
    var mac = AccessControlContext.Current;

    ResearchStudyEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<ResearchStudyEntity> query = db.ResearchStudies.AccessScopeFiltered();

      query = query.Where((e)=>e.ResearchStudyUid == researchStudyUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating ResearchStudy failed: no record with this PK!");
        }
        return false;
      }

      db.ResearchStudies.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A ResearchStudy was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(ResearchStudyEntity entity, StudyManagementDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<ResearchStudyEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    if(!db.Institutes.Where((tgt)=> tgt.InstituteUid==entity.InitiatorInstituteUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    if(!db.SystemEndpoints.Where((tgt)=> tgt.SystemEndpointUid==entity.OriginWdrEndpointUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    if(!db.SystemEndpoints.Where((tgt)=> tgt.SystemEndpointUid==entity.PrimaryImsEndpointUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    return true;
  }

}

/// <summary> Provides CRUD access to stored Sites (based on schema version '1.6.0') </summary>
public partial class SiteStore : ISites {

  private ILogger _Logger = null;
  public SiteStore(ILogger<SiteStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific Site addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="siteUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public Site GetSiteBySiteUid(Guid siteUid){
    var mac = AccessControlContext.Current;

    Site result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.Sites.AsNoTracking().AccessScopeFiltered().Select(SiteEntity.SiteSelector);

      query = query.Where((e)=>e.SiteUid == siteUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads Sites. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of Sites which should be returned </param>
  public Site[] GetSites(int page = 1, int pageSize = 20){
    return this.SearchSites(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {"TerminatedReason", "StudyRelatedSiteIdentifer", "DisplayLabel", "Status", "SiteRelatedProjectNumber"};

  /// <summary> Loads Sites where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of Sites which should be returned</param>
  public Site[] SearchSites(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    Site[] result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.Sites
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(SiteEntity.SiteSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("SiteUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", SiteUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new Site and returns success. </summary>
  /// <param name="site"> Site containing the new values </param>
  public bool AddNewSite(Site site){
    var mac = AccessControlContext.Current;

    SiteEntity newEntity = new SiteEntity();
    newEntity.CopyContentFrom(site);

    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding Site failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.Sites.Where((e)=>e.SiteUid == newEntity.SiteUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding Site failed: already existing record with this PK!");
        }
        return false;
      }

      db.Sites.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A Site was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given Site addressed by the primary identifier fields within the given Site. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="site"> Site containing the new values (the primary identifier fields within the given Site will be used to address the target record) </param>
  public bool UpdateSite(Site site){
    return this.UpdateSiteBySiteUid(site.SiteUid, site);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given Site addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="siteUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  /// <param name="site"> Site containing the new values (the primary identifier fields within the given Site will be ignored) </param>
  public bool UpdateSiteBySiteUid(Guid siteUid, Site site){
    var mac = AccessControlContext.Current;

    SiteEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<SiteEntity> query = db.Sites;

      query = query.Where((e)=>e.SiteUid == siteUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating Site failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(site, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating Site failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating Site failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A Site was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific Site addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="siteUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public bool DeleteSiteBySiteUid(Guid siteUid){
    var mac = AccessControlContext.Current;

    SiteEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<SiteEntity> query = db.Sites.AccessScopeFiltered();

      query = query.Where((e)=>e.SiteUid == siteUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating Site failed: no record with this PK!");
        }
        return false;
      }

      db.Sites.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A Site was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(SiteEntity entity, StudyManagementDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<SiteEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    if(!db.Institutes.Where((tgt)=> tgt.InstituteUid==entity.RepresentingInstituteUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    if(!db.ResearchStudies.Where((tgt)=> tgt.ResearchStudyUid==entity.ResearchStudyUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    return true;
  }

}

/// <summary> Provides CRUD access to stored SystemEndpoints (based on schema version '1.6.0') </summary>
public partial class SystemEndpointStore : ISystemEndpoints {

  private ILogger _Logger = null;
  public SystemEndpointStore(ILogger<SystemEndpointStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific SystemEndpoint addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="systemEndpointUid"> Represents the primary identity of a SystemEndpoint </param>
  public SystemEndpoint GetSystemEndpointBySystemEndpointUid(Guid systemEndpointUid){
    var mac = AccessControlContext.Current;

    SystemEndpoint result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.SystemEndpoints.AsNoTracking().AccessScopeFiltered().Select(SystemEndpointEntity.SystemEndpointSelector);

      query = query.Where((e)=>e.SystemEndpointUid == systemEndpointUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads SystemEndpoints. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of SystemEndpoints which should be returned </param>
  public SystemEndpoint[] GetSystemEndpoints(int page = 1, int pageSize = 20){
    return this.SearchSystemEndpoints(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {"AvailableRoles", "Url", "ApprovedCert", "IsPublic", "Label"};

  /// <summary> Loads SystemEndpoints where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of SystemEndpoints which should be returned</param>
  public SystemEndpoint[] SearchSystemEndpoints(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    SystemEndpoint[] result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.SystemEndpoints
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(SystemEndpointEntity.SystemEndpointSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("SystemEndpointUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", SystemEndpointUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new SystemEndpoint and returns success. </summary>
  /// <param name="systemEndpoint"> SystemEndpoint containing the new values </param>
  public bool AddNewSystemEndpoint(SystemEndpoint systemEndpoint){
    var mac = AccessControlContext.Current;

    SystemEndpointEntity newEntity = new SystemEndpointEntity();
    newEntity.CopyContentFrom(systemEndpoint);

    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding SystemEndpoint failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.SystemEndpoints.Where((e)=>e.SystemEndpointUid == newEntity.SystemEndpointUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding SystemEndpoint failed: already existing record with this PK!");
        }
        return false;
      }

      db.SystemEndpoints.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SystemEndpoint was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given SystemEndpoint addressed by the primary identifier fields within the given SystemEndpoint. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="systemEndpoint"> SystemEndpoint containing the new values (the primary identifier fields within the given SystemEndpoint will be used to address the target record) </param>
  public bool UpdateSystemEndpoint(SystemEndpoint systemEndpoint){
    return this.UpdateSystemEndpointBySystemEndpointUid(systemEndpoint.SystemEndpointUid, systemEndpoint);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given SystemEndpoint addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="systemEndpointUid"> Represents the primary identity of a SystemEndpoint </param>
  /// <param name="systemEndpoint"> SystemEndpoint containing the new values (the primary identifier fields within the given SystemEndpoint will be ignored) </param>
  public bool UpdateSystemEndpointBySystemEndpointUid(Guid systemEndpointUid, SystemEndpoint systemEndpoint){
    var mac = AccessControlContext.Current;

    SystemEndpointEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<SystemEndpointEntity> query = db.SystemEndpoints;

      query = query.Where((e)=>e.SystemEndpointUid == systemEndpointUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SystemEndpoint failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(systemEndpoint, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SystemEndpoint failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating SystemEndpoint failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SystemEndpoint was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific SystemEndpoint addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="systemEndpointUid"> Represents the primary identity of a SystemEndpoint </param>
  public bool DeleteSystemEndpointBySystemEndpointUid(Guid systemEndpointUid){
    var mac = AccessControlContext.Current;

    SystemEndpointEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<SystemEndpointEntity> query = db.SystemEndpoints.AccessScopeFiltered();

      query = query.Where((e)=>e.SystemEndpointUid == systemEndpointUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SystemEndpoint failed: no record with this PK!");
        }
        return false;
      }

      db.SystemEndpoints.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SystemEndpoint was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(SystemEndpointEntity entity, StudyManagementDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<SystemEndpointEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    if(!db.Institutes.Where((tgt)=> tgt.InstituteUid==entity.ProviderInstituteUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    return true;
  }

}

/// <summary> Provides CRUD access to stored InstituteRelatedSystemAssignemnts (based on schema version '1.6.0') </summary>
public partial class InstituteRelatedSystemAssignemntStore : IInstituteRelatedSystemAssignemnts {

  private ILogger _Logger = null;
  public InstituteRelatedSystemAssignemntStore(ILogger<InstituteRelatedSystemAssignemntStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific InstituteRelatedSystemAssignemnt addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="instituteRelatedSystemAssignemntUid"> Represents the primary identity of a InstituteRelatedSystemAssignemnt </param>
  public InstituteRelatedSystemAssignemnt GetInstituteRelatedSystemAssignemntByInstituteRelatedSystemAssignemntUid(Guid instituteRelatedSystemAssignemntUid){
    var mac = AccessControlContext.Current;

    InstituteRelatedSystemAssignemnt result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.InstituteRelatedSystemAssignemnts.AsNoTracking().AccessScopeFiltered().Select(InstituteRelatedSystemAssignemntEntity.InstituteRelatedSystemAssignemntSelector);

      query = query.Where((e)=>e.InstituteRelatedSystemAssignemntUid == instituteRelatedSystemAssignemntUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads InstituteRelatedSystemAssignemnts. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of InstituteRelatedSystemAssignemnts which should be returned </param>
  public InstituteRelatedSystemAssignemnt[] GetInstituteRelatedSystemAssignemnts(int page = 1, int pageSize = 20){
    return this.SearchInstituteRelatedSystemAssignemnts(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {"UseAsOwnPatientSdr", "UseAsCandidateSdr", "UseAsOwnWdr", "UseAsConsumingExternalWdr"};

  /// <summary> Loads InstituteRelatedSystemAssignemnts where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of InstituteRelatedSystemAssignemnts which should be returned</param>
  public InstituteRelatedSystemAssignemnt[] SearchInstituteRelatedSystemAssignemnts(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    InstituteRelatedSystemAssignemnt[] result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.InstituteRelatedSystemAssignemnts
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(InstituteRelatedSystemAssignemntEntity.InstituteRelatedSystemAssignemntSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("InstituteRelatedSystemAssignemntUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", InstituteRelatedSystemAssignemntUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new InstituteRelatedSystemAssignemnt and returns success. </summary>
  /// <param name="instituteRelatedSystemAssignemnt"> InstituteRelatedSystemAssignemnt containing the new values </param>
  public bool AddNewInstituteRelatedSystemAssignemnt(InstituteRelatedSystemAssignemnt instituteRelatedSystemAssignemnt){
    var mac = AccessControlContext.Current;

    InstituteRelatedSystemAssignemntEntity newEntity = new InstituteRelatedSystemAssignemntEntity();
    newEntity.CopyContentFrom(instituteRelatedSystemAssignemnt);

    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding InstituteRelatedSystemAssignemnt failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.InstituteRelatedSystemAssignemnts.Where((e)=>e.InstituteRelatedSystemAssignemntUid == newEntity.InstituteRelatedSystemAssignemntUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding InstituteRelatedSystemAssignemnt failed: already existing record with this PK!");
        }
        return false;
      }

      db.InstituteRelatedSystemAssignemnts.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A InstituteRelatedSystemAssignemnt was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given InstituteRelatedSystemAssignemnt addressed by the primary identifier fields within the given InstituteRelatedSystemAssignemnt. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="instituteRelatedSystemAssignemnt"> InstituteRelatedSystemAssignemnt containing the new values (the primary identifier fields within the given InstituteRelatedSystemAssignemnt will be used to address the target record) </param>
  public bool UpdateInstituteRelatedSystemAssignemnt(InstituteRelatedSystemAssignemnt instituteRelatedSystemAssignemnt){
    return this.UpdateInstituteRelatedSystemAssignemntByInstituteRelatedSystemAssignemntUid(instituteRelatedSystemAssignemnt.InstituteRelatedSystemAssignemntUid, instituteRelatedSystemAssignemnt);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given InstituteRelatedSystemAssignemnt addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="instituteRelatedSystemAssignemntUid"> Represents the primary identity of a InstituteRelatedSystemAssignemnt </param>
  /// <param name="instituteRelatedSystemAssignemnt"> InstituteRelatedSystemAssignemnt containing the new values (the primary identifier fields within the given InstituteRelatedSystemAssignemnt will be ignored) </param>
  public bool UpdateInstituteRelatedSystemAssignemntByInstituteRelatedSystemAssignemntUid(Guid instituteRelatedSystemAssignemntUid, InstituteRelatedSystemAssignemnt instituteRelatedSystemAssignemnt){
    var mac = AccessControlContext.Current;

    InstituteRelatedSystemAssignemntEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<InstituteRelatedSystemAssignemntEntity> query = db.InstituteRelatedSystemAssignemnts;

      query = query.Where((e)=>e.InstituteRelatedSystemAssignemntUid == instituteRelatedSystemAssignemntUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating InstituteRelatedSystemAssignemnt failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(instituteRelatedSystemAssignemnt, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating InstituteRelatedSystemAssignemnt failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating InstituteRelatedSystemAssignemnt failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A InstituteRelatedSystemAssignemnt was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific InstituteRelatedSystemAssignemnt addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="instituteRelatedSystemAssignemntUid"> Represents the primary identity of a InstituteRelatedSystemAssignemnt </param>
  public bool DeleteInstituteRelatedSystemAssignemntByInstituteRelatedSystemAssignemntUid(Guid instituteRelatedSystemAssignemntUid){
    var mac = AccessControlContext.Current;

    InstituteRelatedSystemAssignemntEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<InstituteRelatedSystemAssignemntEntity> query = db.InstituteRelatedSystemAssignemnts.AccessScopeFiltered();

      query = query.Where((e)=>e.InstituteRelatedSystemAssignemntUid == instituteRelatedSystemAssignemntUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating InstituteRelatedSystemAssignemnt failed: no record with this PK!");
        }
        return false;
      }

      db.InstituteRelatedSystemAssignemnts.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A InstituteRelatedSystemAssignemnt was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(InstituteRelatedSystemAssignemntEntity entity, StudyManagementDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<InstituteRelatedSystemAssignemntEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    if(!db.Institutes.Where((tgt)=> tgt.InstituteUid==entity.InstituteUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    if(!db.SystemEndpoints.Where((tgt)=> tgt.SystemEndpointUid==entity.SystemEndpointUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    return true;
  }

}

/// <summary> Provides CRUD access to stored SystemConnections (based on schema version '1.6.0') </summary>
public partial class SystemConnectionStore : ISystemConnections {

  private ILogger _Logger = null;
  public SystemConnectionStore(ILogger<SystemConnectionStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific SystemConnection addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="systemConnectionUid"> Represents the primary identity of a SystemConnection </param>
  public SystemConnection GetSystemConnectionBySystemConnectionUid(Guid systemConnectionUid){
    var mac = AccessControlContext.Current;

    SystemConnection result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.SystemConnections.AsNoTracking().AccessScopeFiltered().Select(SystemConnectionEntity.SystemConnectionSelector);

      query = query.Where((e)=>e.SystemConnectionUid == systemConnectionUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads SystemConnections. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of SystemConnections which should be returned </param>
  public SystemConnection[] GetSystemConnections(int page = 1, int pageSize = 20){
    return this.SearchSystemConnections(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {"HierSpterJWTSEttings"};

  /// <summary> Loads SystemConnections where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of SystemConnections which should be returned</param>
  public SystemConnection[] SearchSystemConnections(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    SystemConnection[] result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.SystemConnections
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(SystemConnectionEntity.SystemConnectionSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("SystemConnectionUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", SystemConnectionUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new SystemConnection and returns success. </summary>
  /// <param name="systemConnection"> SystemConnection containing the new values </param>
  public bool AddNewSystemConnection(SystemConnection systemConnection){
    var mac = AccessControlContext.Current;

    SystemConnectionEntity newEntity = new SystemConnectionEntity();
    newEntity.CopyContentFrom(systemConnection);

    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding SystemConnection failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.SystemConnections.Where((e)=>e.SystemConnectionUid == newEntity.SystemConnectionUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding SystemConnection failed: already existing record with this PK!");
        }
        return false;
      }

      db.SystemConnections.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SystemConnection was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given SystemConnection addressed by the primary identifier fields within the given SystemConnection. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="systemConnection"> SystemConnection containing the new values (the primary identifier fields within the given SystemConnection will be used to address the target record) </param>
  public bool UpdateSystemConnection(SystemConnection systemConnection){
    return this.UpdateSystemConnectionBySystemConnectionUid(systemConnection.SystemConnectionUid, systemConnection);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given SystemConnection addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="systemConnectionUid"> Represents the primary identity of a SystemConnection </param>
  /// <param name="systemConnection"> SystemConnection containing the new values (the primary identifier fields within the given SystemConnection will be ignored) </param>
  public bool UpdateSystemConnectionBySystemConnectionUid(Guid systemConnectionUid, SystemConnection systemConnection){
    var mac = AccessControlContext.Current;

    SystemConnectionEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<SystemConnectionEntity> query = db.SystemConnections;

      query = query.Where((e)=>e.SystemConnectionUid == systemConnectionUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SystemConnection failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(systemConnection, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SystemConnection failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating SystemConnection failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SystemConnection was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific SystemConnection addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="systemConnectionUid"> Represents the primary identity of a SystemConnection </param>
  public bool DeleteSystemConnectionBySystemConnectionUid(Guid systemConnectionUid){
    var mac = AccessControlContext.Current;

    SystemConnectionEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<SystemConnectionEntity> query = db.SystemConnections.AccessScopeFiltered();

      query = query.Where((e)=>e.SystemConnectionUid == systemConnectionUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SystemConnection failed: no record with this PK!");
        }
        return false;
      }

      db.SystemConnections.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SystemConnection was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(SystemConnectionEntity entity, StudyManagementDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<SystemConnectionEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    if(!db.Institutes.Where((tgt)=> tgt.InstituteUid==entity.OwnerInstituteUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    if(!db.SiteRelatedSystemAssignments.Where((tgt)=> tgt.SiteRelatedSystemAssignmentUid==entity.DedicatedSiteRelatedSystemAssignmentUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    if(!db.SystemEndpoints.Where((tgt)=> tgt.SystemEndpointUid==entity.TargetSystemEndpointUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    return true;
  }

}

/// <summary> Provides CRUD access to stored InvolvedPersons (based on schema version '1.6.0') </summary>
public partial class InvolvedPersonStore : IInvolvedPersons {

  private ILogger _Logger = null;
  public InvolvedPersonStore(ILogger<InvolvedPersonStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific InvolvedPerson addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="involvedPersonUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public InvolvedPerson GetInvolvedPersonByInvolvedPersonUid(Guid involvedPersonUid){
    var mac = AccessControlContext.Current;

    InvolvedPerson result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.InvolvedPersons.AsNoTracking().AccessScopeFiltered().Select(InvolvedPersonEntity.InvolvedPersonSelector);

      query = query.Where((e)=>e.InvolvedPersonUid == involvedPersonUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads InvolvedPersons. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of InvolvedPersons which should be returned </param>
  public InvolvedPerson[] GetInvolvedPersons(int page = 1, int pageSize = 20){
    return this.SearchInvolvedPersons(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {"DisplayLabel"};

  /// <summary> Loads InvolvedPersons where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of InvolvedPersons which should be returned</param>
  public InvolvedPerson[] SearchInvolvedPersons(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    InvolvedPerson[] result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.InvolvedPersons
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(InvolvedPersonEntity.InvolvedPersonSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("InvolvedPersonUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", InvolvedPersonUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new InvolvedPerson and returns success. </summary>
  /// <param name="involvedPerson"> InvolvedPerson containing the new values </param>
  public bool AddNewInvolvedPerson(InvolvedPerson involvedPerson){
    var mac = AccessControlContext.Current;

    InvolvedPersonEntity newEntity = new InvolvedPersonEntity();
    newEntity.CopyContentFrom(involvedPerson);

    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding InvolvedPerson failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.InvolvedPersons.Where((e)=>e.InvolvedPersonUid == newEntity.InvolvedPersonUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding InvolvedPerson failed: already existing record with this PK!");
        }
        return false;
      }

      db.InvolvedPersons.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A InvolvedPerson was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given InvolvedPerson addressed by the primary identifier fields within the given InvolvedPerson. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="involvedPerson"> InvolvedPerson containing the new values (the primary identifier fields within the given InvolvedPerson will be used to address the target record) </param>
  public bool UpdateInvolvedPerson(InvolvedPerson involvedPerson){
    return this.UpdateInvolvedPersonByInvolvedPersonUid(involvedPerson.InvolvedPersonUid, involvedPerson);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given InvolvedPerson addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="involvedPersonUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  /// <param name="involvedPerson"> InvolvedPerson containing the new values (the primary identifier fields within the given InvolvedPerson will be ignored) </param>
  public bool UpdateInvolvedPersonByInvolvedPersonUid(Guid involvedPersonUid, InvolvedPerson involvedPerson){
    var mac = AccessControlContext.Current;

    InvolvedPersonEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<InvolvedPersonEntity> query = db.InvolvedPersons;

      query = query.Where((e)=>e.InvolvedPersonUid == involvedPersonUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating InvolvedPerson failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(involvedPerson, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating InvolvedPerson failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating InvolvedPerson failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A InvolvedPerson was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific InvolvedPerson addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="involvedPersonUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public bool DeleteInvolvedPersonByInvolvedPersonUid(Guid involvedPersonUid){
    var mac = AccessControlContext.Current;

    InvolvedPersonEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<InvolvedPersonEntity> query = db.InvolvedPersons.AccessScopeFiltered();

      query = query.Where((e)=>e.InvolvedPersonUid == involvedPersonUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating InvolvedPerson failed: no record with this PK!");
        }
        return false;
      }

      db.InvolvedPersons.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A InvolvedPerson was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(InvolvedPersonEntity entity, StudyManagementDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<InvolvedPersonEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    return true;
  }

}

/// <summary> Provides CRUD access to stored InvolvementRoles (based on schema version '1.6.0') </summary>
public partial class InvolvementRoleStore : IInvolvementRoles {

  private ILogger _Logger = null;
  public InvolvementRoleStore(ILogger<InvolvementRoleStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific InvolvementRole addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="involvedPersonRoleUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public InvolvementRole GetInvolvementRoleByInvolvedPersonRoleUid(Guid involvedPersonRoleUid){
    var mac = AccessControlContext.Current;

    InvolvementRole result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.InvolvementRoles.AsNoTracking().AccessScopeFiltered().Select(InvolvementRoleEntity.InvolvementRoleSelector);

      query = query.Where((e)=>e.InvolvedPersonRoleUid == involvedPersonRoleUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads InvolvementRoles. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of InvolvementRoles which should be returned </param>
  public InvolvementRole[] GetInvolvementRoles(int page = 1, int pageSize = 20){
    return this.SearchInvolvementRoles(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {"Role"};

  /// <summary> Loads InvolvementRoles where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of InvolvementRoles which should be returned</param>
  public InvolvementRole[] SearchInvolvementRoles(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    InvolvementRole[] result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.InvolvementRoles
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(InvolvementRoleEntity.InvolvementRoleSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("InvolvedPersonRoleUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", InvolvedPersonRoleUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new InvolvementRole and returns success. </summary>
  /// <param name="involvementRole"> InvolvementRole containing the new values </param>
  public bool AddNewInvolvementRole(InvolvementRole involvementRole){
    var mac = AccessControlContext.Current;

    InvolvementRoleEntity newEntity = new InvolvementRoleEntity();
    newEntity.CopyContentFrom(involvementRole);

    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding InvolvementRole failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.InvolvementRoles.Where((e)=>e.InvolvedPersonRoleUid == newEntity.InvolvedPersonRoleUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding InvolvementRole failed: already existing record with this PK!");
        }
        return false;
      }

      db.InvolvementRoles.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A InvolvementRole was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given InvolvementRole addressed by the primary identifier fields within the given InvolvementRole. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="involvementRole"> InvolvementRole containing the new values (the primary identifier fields within the given InvolvementRole will be used to address the target record) </param>
  public bool UpdateInvolvementRole(InvolvementRole involvementRole){
    return this.UpdateInvolvementRoleByInvolvedPersonRoleUid(involvementRole.InvolvedPersonRoleUid, involvementRole);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given InvolvementRole addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="involvedPersonRoleUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  /// <param name="involvementRole"> InvolvementRole containing the new values (the primary identifier fields within the given InvolvementRole will be ignored) </param>
  public bool UpdateInvolvementRoleByInvolvedPersonRoleUid(Guid involvedPersonRoleUid, InvolvementRole involvementRole){
    var mac = AccessControlContext.Current;

    InvolvementRoleEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<InvolvementRoleEntity> query = db.InvolvementRoles;

      query = query.Where((e)=>e.InvolvedPersonRoleUid == involvedPersonRoleUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating InvolvementRole failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(involvementRole, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating InvolvementRole failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating InvolvementRole failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A InvolvementRole was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific InvolvementRole addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="involvedPersonRoleUid"> An <see href="https://de.wikipedia.org/wiki/Universally_Unique_Identifier">Universally Unique Identifier</see> which can be generated by any origin system and is used to address this ORSCF conform data record in decentralized environments. Note that this Identity must not be changed any more! </param>
  public bool DeleteInvolvementRoleByInvolvedPersonRoleUid(Guid involvedPersonRoleUid){
    var mac = AccessControlContext.Current;

    InvolvementRoleEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<InvolvementRoleEntity> query = db.InvolvementRoles.AccessScopeFiltered();

      query = query.Where((e)=>e.InvolvedPersonRoleUid == involvedPersonRoleUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating InvolvementRole failed: no record with this PK!");
        }
        return false;
      }

      db.InvolvementRoles.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A InvolvementRole was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(InvolvementRoleEntity entity, StudyManagementDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<InvolvementRoleEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    if(!db.InvolvedPersons.Where((tgt)=> tgt.InvolvedPersonUid==entity.InvolvedPersonUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    if(!db.ResearchStudies.Where((tgt)=> tgt.ResearchStudyUid==entity.ResearchStudyUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    if(!db.Sites.Where((tgt)=> tgt.SiteUid==entity.DedicatedToSiteUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    return true;
  }

}

/// <summary> Provides CRUD access to stored StudyRelatedSystemAssignments (based on schema version '1.6.0') </summary>
public partial class StudyRelatedSystemAssignmentStore : IStudyRelatedSystemAssignments {

  private ILogger _Logger = null;
  public StudyRelatedSystemAssignmentStore(ILogger<StudyRelatedSystemAssignmentStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific StudyRelatedSystemAssignment addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="studyRelatedSystemAssignmentUid"> Represents the primary identity of a StudyRelatedSystemAssignment </param>
  public StudyRelatedSystemAssignment GetStudyRelatedSystemAssignmentByStudyRelatedSystemAssignmentUid(Guid studyRelatedSystemAssignmentUid){
    var mac = AccessControlContext.Current;

    StudyRelatedSystemAssignment result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.StudyRelatedSystemAssignments.AsNoTracking().AccessScopeFiltered().Select(StudyRelatedSystemAssignmentEntity.StudyRelatedSystemAssignmentSelector);

      query = query.Where((e)=>e.StudyRelatedSystemAssignmentUid == studyRelatedSystemAssignmentUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads StudyRelatedSystemAssignments. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of StudyRelatedSystemAssignments which should be returned </param>
  public StudyRelatedSystemAssignment[] GetStudyRelatedSystemAssignments(int page = 1, int pageSize = 20){
    return this.SearchStudyRelatedSystemAssignments(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {};

  /// <summary> Loads StudyRelatedSystemAssignments where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of StudyRelatedSystemAssignments which should be returned</param>
  public StudyRelatedSystemAssignment[] SearchStudyRelatedSystemAssignments(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    StudyRelatedSystemAssignment[] result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.StudyRelatedSystemAssignments
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(StudyRelatedSystemAssignmentEntity.StudyRelatedSystemAssignmentSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("StudyRelatedSystemAssignmentUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", StudyRelatedSystemAssignmentUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new StudyRelatedSystemAssignment and returns success. </summary>
  /// <param name="studyRelatedSystemAssignment"> StudyRelatedSystemAssignment containing the new values </param>
  public bool AddNewStudyRelatedSystemAssignment(StudyRelatedSystemAssignment studyRelatedSystemAssignment){
    var mac = AccessControlContext.Current;

    StudyRelatedSystemAssignmentEntity newEntity = new StudyRelatedSystemAssignmentEntity();
    newEntity.CopyContentFrom(studyRelatedSystemAssignment);

    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding StudyRelatedSystemAssignment failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.StudyRelatedSystemAssignments.Where((e)=>e.StudyRelatedSystemAssignmentUid == newEntity.StudyRelatedSystemAssignmentUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding StudyRelatedSystemAssignment failed: already existing record with this PK!");
        }
        return false;
      }

      db.StudyRelatedSystemAssignments.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A StudyRelatedSystemAssignment was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given StudyRelatedSystemAssignment addressed by the primary identifier fields within the given StudyRelatedSystemAssignment. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="studyRelatedSystemAssignment"> StudyRelatedSystemAssignment containing the new values (the primary identifier fields within the given StudyRelatedSystemAssignment will be used to address the target record) </param>
  public bool UpdateStudyRelatedSystemAssignment(StudyRelatedSystemAssignment studyRelatedSystemAssignment){
    return this.UpdateStudyRelatedSystemAssignmentByStudyRelatedSystemAssignmentUid(studyRelatedSystemAssignment.StudyRelatedSystemAssignmentUid, studyRelatedSystemAssignment);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given StudyRelatedSystemAssignment addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="studyRelatedSystemAssignmentUid"> Represents the primary identity of a StudyRelatedSystemAssignment </param>
  /// <param name="studyRelatedSystemAssignment"> StudyRelatedSystemAssignment containing the new values (the primary identifier fields within the given StudyRelatedSystemAssignment will be ignored) </param>
  public bool UpdateStudyRelatedSystemAssignmentByStudyRelatedSystemAssignmentUid(Guid studyRelatedSystemAssignmentUid, StudyRelatedSystemAssignment studyRelatedSystemAssignment){
    var mac = AccessControlContext.Current;

    StudyRelatedSystemAssignmentEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<StudyRelatedSystemAssignmentEntity> query = db.StudyRelatedSystemAssignments;

      query = query.Where((e)=>e.StudyRelatedSystemAssignmentUid == studyRelatedSystemAssignmentUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating StudyRelatedSystemAssignment failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(studyRelatedSystemAssignment, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating StudyRelatedSystemAssignment failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating StudyRelatedSystemAssignment failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A StudyRelatedSystemAssignment was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific StudyRelatedSystemAssignment addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="studyRelatedSystemAssignmentUid"> Represents the primary identity of a StudyRelatedSystemAssignment </param>
  public bool DeleteStudyRelatedSystemAssignmentByStudyRelatedSystemAssignmentUid(Guid studyRelatedSystemAssignmentUid){
    var mac = AccessControlContext.Current;

    StudyRelatedSystemAssignmentEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<StudyRelatedSystemAssignmentEntity> query = db.StudyRelatedSystemAssignments.AccessScopeFiltered();

      query = query.Where((e)=>e.StudyRelatedSystemAssignmentUid == studyRelatedSystemAssignmentUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating StudyRelatedSystemAssignment failed: no record with this PK!");
        }
        return false;
      }

      db.StudyRelatedSystemAssignments.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A StudyRelatedSystemAssignment was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(StudyRelatedSystemAssignmentEntity entity, StudyManagementDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<StudyRelatedSystemAssignmentEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    if(!db.ResearchStudies.Where((tgt)=> tgt.ResearchStudyUid==entity.ResearchStudyUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    if(!db.SystemEndpoints.Where((tgt)=> tgt.SystemEndpointUid==entity.SystemEndpointUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    return true;
  }

}

/// <summary> Provides CRUD access to stored SiteRelatedSystemAssignments (based on schema version '1.6.0') </summary>
public partial class SiteRelatedSystemAssignmentStore : ISiteRelatedSystemAssignments {

  private ILogger _Logger = null;
  public SiteRelatedSystemAssignmentStore(ILogger<SiteRelatedSystemAssignmentStore> logger){
    _Logger = logger;
  }

  /// <summary> Loads a specific SiteRelatedSystemAssignment addressed by the given primary identifier. Returns null on failure, or if no record exists with the given identity.</summary>
  /// <param name="siteRelatedSystemAssignmentUid"> Represents the primary identity of a SiteRelatedSystemAssignment </param>
  public SiteRelatedSystemAssignment GetSiteRelatedSystemAssignmentBySiteRelatedSystemAssignmentUid(Guid siteRelatedSystemAssignmentUid){
    var mac = AccessControlContext.Current;

    SiteRelatedSystemAssignment result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.SiteRelatedSystemAssignments.AsNoTracking().AccessScopeFiltered().Select(SiteRelatedSystemAssignmentEntity.SiteRelatedSystemAssignmentSelector);

      query = query.Where((e)=>e.SiteRelatedSystemAssignmentUid == siteRelatedSystemAssignmentUid);

      //materialization / load
      result = query.SingleOrDefault();

    }

    return result;
  }

  /// <summary> Loads SiteRelatedSystemAssignments. </summary>
  /// <param name="page">Number of the page, which should be returned </param>
  /// <param name="pageSize">Max count of SiteRelatedSystemAssignments which should be returned </param>
  public SiteRelatedSystemAssignment[] GetSiteRelatedSystemAssignments(int page = 1, int pageSize = 20){
    return this.SearchSiteRelatedSystemAssignments(null, null, page, pageSize); 
  }

  private static String[] _ExactMatchPropNames = new String[] {};
  private static String[] _FreetextPropNames = new String[] {};

  /// <summary> Loads SiteRelatedSystemAssignments where values matching to the given filterExpression</summary>
  /// <param name="filterExpression">a filter expression like '((FieldName1 == "ABC" &amp;&amp; FieldName2 &gt; 12) || FieldName2 != "")' OR just '*' for all records</param>
  /// <param name="sortingExpression">one or more property names which are used as sort order (before pagination)</param>
  /// <param name="page">Number of the page, which should be returned</param>
  /// <param name="pageSize">Max count of SiteRelatedSystemAssignments which should be returned</param>
  public SiteRelatedSystemAssignment[] SearchSiteRelatedSystemAssignments(String filterExpression, String sortingExpression = null, int page = 1, int pageSize = 20){
    var mac = AccessControlContext.Current;

    if(page < 1){
      page = 1;
    }
    if(pageSize < 1 || pageSize > 10000){
      pageSize = 20;
    }

    SiteRelatedSystemAssignment[] result;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //select models, bacause we dont want to return types with navigation-properties!
      var query = db.SiteRelatedSystemAssignments
        .AsNoTracking()
        .AccessScopeFiltered()
        .Select(SiteRelatedSystemAssignmentEntity.SiteRelatedSystemAssignmentSelector)
      ;
      
      //apply filter (if given)
      if(!String.IsNullOrWhiteSpace(filterExpression) && filterExpression != "*") {
        //just if the filterExpression isnt already a valid expression, treat it as a freetext seach string and transform it to a valid expression
        filterExpression = DynamicLinqExtensions.FreetextSearchStringToFilterExpression(filterExpression, _ExactMatchPropNames, _FreetextPropNames);
        if(filterExpression != null) {
          query = query.DynamicallyFiltered(filterExpression);
        }
      }

      //apply sorting
      if(String.IsNullOrWhiteSpace(sortingExpression)) {
        query = query.DynamicallySorted("SiteRelatedSystemAssignmentUid");
      }
      else{
        query = query.DynamicallySorted(sortingExpression + ", SiteRelatedSystemAssignmentUid");
      }

      //apply pagination
      query = query.Skip(pageSize * (page - 1)).Take(pageSize);

      //materialization / load
      result = query.ToArray();

    }

    return result;
  }

  /// <summary> Adds a new SiteRelatedSystemAssignment and returns success. </summary>
  /// <param name="siteRelatedSystemAssignment"> SiteRelatedSystemAssignment containing the new values </param>
  public bool AddNewSiteRelatedSystemAssignment(SiteRelatedSystemAssignment siteRelatedSystemAssignment){
    var mac = AccessControlContext.Current;

    SiteRelatedSystemAssignmentEntity newEntity = new SiteRelatedSystemAssignmentEntity();
    newEntity.CopyContentFrom(siteRelatedSystemAssignment);

    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(newEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Adding SiteRelatedSystemAssignment failed: record would be out of access control scope!");
        }
        return false;
      }

      if (db.SiteRelatedSystemAssignments.Where((e)=>e.SiteRelatedSystemAssignmentUid == newEntity.SiteRelatedSystemAssignmentUid).Any()) {
        if(_Logger != null){
          _Logger.LogInformation("Adding SiteRelatedSystemAssignment failed: already existing record with this PK!");
        }
        return false;
      }

      db.SiteRelatedSystemAssignments.Add(newEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SiteRelatedSystemAssignment was added!");
    }

    return true;
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given SiteRelatedSystemAssignment addressed by the primary identifier fields within the given SiteRelatedSystemAssignment. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="siteRelatedSystemAssignment"> SiteRelatedSystemAssignment containing the new values (the primary identifier fields within the given SiteRelatedSystemAssignment will be used to address the target record) </param>
  public bool UpdateSiteRelatedSystemAssignment(SiteRelatedSystemAssignment siteRelatedSystemAssignment){
    return this.UpdateSiteRelatedSystemAssignmentBySiteRelatedSystemAssignmentUid(siteRelatedSystemAssignment.SiteRelatedSystemAssignmentUid, siteRelatedSystemAssignment);
  }

  /// <summary> Updates all values (which are not "FixedAfterCreation") of the given SiteRelatedSystemAssignment addressed by the supplementary given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="siteRelatedSystemAssignmentUid"> Represents the primary identity of a SiteRelatedSystemAssignment </param>
  /// <param name="siteRelatedSystemAssignment"> SiteRelatedSystemAssignment containing the new values (the primary identifier fields within the given SiteRelatedSystemAssignment will be ignored) </param>
  public bool UpdateSiteRelatedSystemAssignmentBySiteRelatedSystemAssignmentUid(Guid siteRelatedSystemAssignmentUid, SiteRelatedSystemAssignment siteRelatedSystemAssignment){
    var mac = AccessControlContext.Current;

    SiteRelatedSystemAssignmentEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<SiteRelatedSystemAssignmentEntity> query = db.SiteRelatedSystemAssignments;

      query = query.Where((e)=>e.SiteRelatedSystemAssignmentUid == siteRelatedSystemAssignmentUid).AccessScopeFiltered();

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if(existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SiteRelatedSystemAssignment failed: no record with this PK!");
        }
        return false;
      }

      bool changeAttemptOnFixedField = false;
      existingEntity.CopyContentFrom(siteRelatedSystemAssignment, (name) => changeAttemptOnFixedField = true);

      if (changeAttemptOnFixedField) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SiteRelatedSystemAssignment failed: change attempt on FIXED field!");
        }
        return false;
      }

      //checks, that the new values are within the access control scope
      if(!this.PreValidateAccessControlScope(existingEntity, db)){
        if(_Logger != null){
          _Logger.LogInformation("Updating SiteRelatedSystemAssignment failed: record would be out of access control scope!");
        }
        return false;
      }

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SiteRelatedSystemAssignment was updated!");
    }

    return true;
  }

  /// <summary> Deletes a specific SiteRelatedSystemAssignment addressed by the given primary identifier. Returns false on failure or if no target record was found, otherwise true.</summary>
  /// <param name="siteRelatedSystemAssignmentUid"> Represents the primary identity of a SiteRelatedSystemAssignment </param>
  public bool DeleteSiteRelatedSystemAssignmentBySiteRelatedSystemAssignmentUid(Guid siteRelatedSystemAssignmentUid){
    var mac = AccessControlContext.Current;

    SiteRelatedSystemAssignmentEntity existingEntity;
    using (StudyManagementDbContext db = new StudyManagementDbContext()) {

      IQueryable<SiteRelatedSystemAssignmentEntity> query = db.SiteRelatedSystemAssignments.AccessScopeFiltered();

      query = query.Where((e)=>e.SiteRelatedSystemAssignmentUid == siteRelatedSystemAssignmentUid);

      //materialization / load
      existingEntity = query.SingleOrDefault();

      if (existingEntity == null) {
        if(_Logger != null){
          _Logger.LogInformation("Updating SiteRelatedSystemAssignment failed: no record with this PK!");
        }
        return false;
      }

      db.SiteRelatedSystemAssignments.Remove(existingEntity);

      db.SaveChanges();
    }
    if(_Logger != null){
      _Logger.LogInformation("A SiteRelatedSystemAssignment was deleted!");
    }

    return true;
  }

  private bool PreValidateAccessControlScope(SiteRelatedSystemAssignmentEntity entity, StudyManagementDbContext db){

    var filterExpression = EntityAccessControl.BuildExpressionForLocalEntity<SiteRelatedSystemAssignmentEntity>(AccessControlContext.Current);
    if(!filterExpression.Compile().Invoke(entity)) {
      return false;
    }

    if(!db.Sites.Where((tgt)=> tgt.SiteUid==entity.SiteUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    if(!db.SystemEndpoints.Where((tgt)=> tgt.SystemEndpointUid==entity.SystemEndpointUid ).AccessScopeFiltered().Any()) {
      return false;
    }
    return true;
  }

}

}
